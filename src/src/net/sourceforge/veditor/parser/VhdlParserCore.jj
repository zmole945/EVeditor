/*******************************************************************************
 * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    KOBAYASHI Tadashi - initial API and implementation
 *******************************************************************************/

options {
	JAVA_UNICODE_ESCAPE = true ;
	STATIC = false ;
	IGNORE_CASE = true ;
}

PARSER_BEGIN(VhdlParserCore)

package net.sourceforge.veditor.parser;

public abstract class VhdlParserCore
{
	protected abstract void addModule(int begin, String name);
	protected abstract void endModule(int line);
	protected abstract void addPort(int line, String portName);
	protected abstract void addVariable(int line, String varName);
	protected abstract void addParameter(int line, String name, String value);
	protected abstract void addElement(int begin, int end, String type, String name);
	protected abstract void addInstance(int begin, int end, String module, String inst);
	protected abstract void beginStatement();
	protected abstract void endStatement();

	public void parse() throws ParseException
	{
		modules();
	}
}

PARSER_END(VhdlParserCore)

//
// operation for /* */
//
MORE :
{
	"/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
	< ~[] >
}


//
// ignore from `else to `endif
//
SKIP :
{
	" " | "\t" | "\r" | "\n" | "\f"
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "--" (~["\n"])* ("\n")>
}

TOKEN :
{
	<LIBRARY:	"library">
|	<BODY:		"body">
|	<PACKAGE:	"package">
|	<USE:		"use">
|	<ENTITY:	"entity">
|	<ARCHITECTURE:	"architecture">
|	<IS:		"is">
|	<OF:		"of">
|	<RECORD:	"record">
|	<GENERIC:	"generic">
|	<PORT:		"port">
|	<PROCESS:	"process">
|	<BEGIN: 	"begin">
|	<END:		"end">
|	<CONSTANT:	"constant">
|	<PROCEDURE:	"procedure">
|	<FUNCTION:	"function">
|	<SIGNAL:	"signal">
|	<SHARED:	"shared">
|	<VARIABLE:	"variable">
|	<TYPE:		"type">
|	<SUBTYPE:	"subtype">
|	<FILE:		"file">
|	<ALIAS:		"alias">
|	<ATTRIBUTE:	"attribute">
|	<COMPONENT:	"component">
|	<FOR:		"for">
|	<IF:		"if">
|	<CASE:		"case">
|	<LOOP:		"loop">
|	<RETURN:	"return">
|	<DISCONNECT:"disconnect">
|	<GROUP:		"group">
|	<BLOCK:		"block">
|	<ASSERT:	"assert">
|	<GENERATE:	"generate">
|	<TO:		"to">
|	<RANGE:		"range">
|	<WITH:		"with">
|	<MODE:		( "in" | "out" | "inout" | "buffer" | "linkage" )>
|	<LPAREN:	"(" >
|	<RPAREN:	")" >
|	<LBRACE: 	"{" >
|	<RBRACE: 	"}" >
|	<LBRACKET:	"[" >
|	<RBRACKET:	"]" >
|	<EOS:		";" >
|	<PARA:		"#" >
|	<AT:		"@" >
|	<BQ:		"`" >
|	<DOLLAR:	"$" >
|	<COMMA:		"," >
|	<COLON:		":" >
|	<ASSIGN:	"<=" >
|	<EQUAL:		"=" >
|	<IDENT: 	([ "a"-"z", "A"-"Z", "0"-"9", "_", ".", "'", "?", "\"" ])+>
|	<SPC_CHAR:	~[ " ", "\t"] >
|	<OTHER:		"[.]" >
}

void modules() :
{
}
{
	(
		<LIBRARY> skipTo( EOS )
	|	<USE> skipTo( EOS )
	|	entity()
	|	architecture()
	|	packageDef()
	)+
}

void entity() :
{	
	Token name ;
	Token end ;
}
{
	<ENTITY> name = identifier() <IS>
	{
		addModule( name.beginLine, name.image );
	}
	(
		<GENERIC> "(" skipParen() ")" <EOS>
	|	<PORT> "(" port() ( ";" port() )* ")" <EOS>
	)*
	<END> [ <ENTITY> ] [ identifier() ] end = <EOS>
	{
		endModule( end.beginLine );
	}
}

void architecture() :
{
	Token end;
}
{
	<ARCHITECTURE> identifier() <OF> identifier() <IS>
	moduleBody()
	[ identifier() ]
	end = <EOS>
	{
		endModule( end.beginLine );
	}
}


void packageDef() :
{
	Token name ;
	Token end ;
}
{
	<PACKAGE> [<BODY>] identifier() <IS>
	(
		packageDeclaration()
|		<COMPONENT> name = identifier() [<IS>]
		{
			addModule( name.beginLine, name.image );
		}
		(
			<GENERIC> "(" skipParen() ")" <EOS>
		|	<PORT> "(" port() ( ";" port() )* ")" <EOS>
		)*
		end = <END> <COMPONENT> <EOS>
		{
			endModule( end.beginLine );
		}
	
	)+
	<END> [identifier()] <EOS>
}

void port() :
{
	Token port ;
}
{
	port = identifier()
	{
		addPort( port.beginLine, port.image );
	}
	(
		","
		port = identifier()
		{
			addPort( port.beginLine, port.image );
		}
	)*
	":" <MODE> identifier()
	(
		<RANGE> identifier() <TO> identifier()
	|	[ "(" skipParen() ")" ]
	)
}

void moduleBody() :
{
	Token	module, inst, iend ;
}
{
	( declaration() )*
	<BEGIN>
	( statement() )*
	<END>
}

Token identifier() :
{
	Token token ;
}
{
	token = <IDENT>
	{
		return token ;
	}
}

void packageDeclaration() :
{
	Token variable;
}
{
	(
		( <CONSTANT> | <SIGNAL> | [ <SHARED> ] <VARIABLE> )
		variable = identifier()
		{
			addVariable( variable.beginLine, variable.image );
		}
		(
			","
			variable = identifier()
			{
				addVariable( variable.beginLine, variable.image );
			}
		)*
		":" skipTo( EOS )
	)
|	( <TYPE> | <SUBTYPE> ) identifier() <IS> 
		(
			( <RECORD> skipEnd() <END> <RECORD> <EOS> )
		|	skipTo( EOS )
		)
|	( <FILE> | <ALIAS> | <ATTRIBUTE> | <FOR> | <DISCONNECT> | <GROUP> ) skipTo( EOS )
|	<PROCEDURE> 
		(
			<EOS>
		|	skipTo( BEGIN ) skipEnd() <END> [ identifier() ] <EOS>
		)
|	<FUNCTION> skipTo( RETURN ) identifier()
		(
			<EOS>
		|	skipTo( BEGIN ) skipEnd() <END> [ identifier() ] <EOS>
		)
}

void declaration() :
{
}
{
	packageDeclaration()
|	<COMPONENT> skipTo2( END, COMPONENT ) skipTo( EOS )
}

void statement() :
{
	Token ident, module, iend;
}
{
	(
		ident = identifier()
		(
			":" {beginStatement();}
			(
				[<ENTITY>] module = identifier() iend = skipTo( EOS )
				{
					addInstance( ident.beginLine, iend.endLine, module.image, ident.image );
				}
			|	( <IF> | <FOR> ) skipTo( GENERATE )
				(
					<BEGIN> ( statement() )* 
				|	( statement() )+
				)
				<END> <GENERATE> [identifier()] <EOS>
			|	<PROCESS> process()
			)
			{endStatement();}
		|	{beginStatement();} [ "(" skipParen() ")" ] skipTo( EOS )
			{endStatement();}
		)
	|	<WITH> {beginStatement();} skipTo( EOS ) {endStatement();}
	|	<PROCESS> {beginStatement();} process() {endStatement();}
	|	<BLOCK> {beginStatement();}
			skipTo2( END, BLOCK ) [ identifier() ] <EOS> {endStatement();}
	|	<ASSERT> {beginStatement();} skipTo( EOS ) {endStatement();}
	)
}

void process() :
{
}
{
	skipTo2( END, PROCESS ) [ identifier() ] <EOS>
}

JAVACODE
Token skipTo( int skip )
{
	Token token ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == skip )
		{
			getNextToken();
			break ;
		}
		getNextToken();
	}
	return token ;
}

JAVACODE
Token skipTo2( int skip1, int skip2 )
{
	Token token ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == skip1 )
		{
			getNextToken();
			token = getToken( 1 );
			if ( token.kind == skip2 )
			{
				getNextToken();
				break ;
			}
		}
		else
			getNextToken();
	}
	return token ;
}

JAVACODE
void skipParen()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == LPAREN )
			nesting++;
		if ( token.kind == RPAREN )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipBracket()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == LBRACKET )
			nesting++;
		if ( token.kind == RBRACKET )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipEnd()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == BEGIN || token.kind == IF || token.kind == CASE || token.kind == LOOP )
			nesting++;
		if ( token.kind == END )
		{
			nesting--;
			if ( nesting == 0 )
				break;
			else
				getNextToken();	// if or case
		}
		getNextToken();
	}
}


