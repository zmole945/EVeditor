/*******************************************************************************
 * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    KOBAYASHI Tadashi - initial API and implementation
 *******************************************************************************/

options {
	JAVA_UNICODE_ESCAPE = true ;
	STATIC = false ;
	IGNORE_CASE = true ;
}

PARSER_BEGIN(VhdlParserCore)

package net.sourceforge.veditor.parser;

public abstract class VhdlParserCore
{
	protected abstract void addModule(int begin, String name);
	protected abstract void endModule(int line);
	protected abstract void addPort(int line, String portName);
	protected abstract void addVariable(int line, String varName);
	protected abstract void addParameter(int line, String name);
	protected abstract void addElement(int begin, int end, String type, String name);
	protected abstract void addInstance(int begin, int end, String module, String inst);
	protected abstract void beginStatement();
	protected abstract void endStatement();
	protected abstract void setPrefix(String fix);
	protected abstract void setPostfix(String fix);

	public void parse() throws ParseException
	{
		modules();
	}
}

PARSER_END(VhdlParserCore)

//
// operation for /* */
//
MORE :
{
	"/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
	< ~[] >
}


//
// ignore from `else to `endif
//
SKIP :
{
	" " | "\t" | "\r" | "\n" | "\f"
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "--" (~["\n"])* ("\n")>
}

TOKEN :
{
	<LIBRARY:	"library">
|	<BODY:		"body">
|	<PACKAGE:	"package">
|	<USE:		"use">
|	<ENTITY:	"entity">
|	<ARCHITECTURE:	"architecture">
|	<IS:		"is">
|	<OF:		"of">
|	<RECORD:	"record">
|	<GENERIC:	"generic">
|	<PORT:		"port">
|	<PROCESS:	"process">
|	<BEGIN: 	"begin">
|	<END:		"end">
|	<CONSTANT:	"constant">
|	<PROCEDURE:	"procedure">
|	<FUNCTION:	"function">
|	<SIGNAL:	"signal">
|	<SHARED:	"shared">
|	<VARIABLE:	"variable">
|	<TYPE:		"type">
|	<SUBTYPE:	"subtype">
|	<FILE:		"file">
|	<ALIAS:		"alias">
|	<ATTRIBUTE:	"attribute">
|	<COMPONENT:	"component">
|	<FOR:		"for">
|	<IF:		"if">
|	<CASE:		"case">
|	<LOOP:		"loop">
|	<RETURN:	"return">
|	<DISCONNECT:"disconnect">
|	<GROUP:		"group">
|	<BLOCK:		"block">
|	<ASSERT:	"assert">
|	<GENERATE:	"generate">
|	<TO:		"to">
|	<RANGE:		"range">
|	<WITH:		"with">
|	<MODE:		( "in" | "out" | "inout" | "buffer" | "linkage" )>
|	<LPAREN:	"(" >
|	<RPAREN:	")" >
|	<LBRACE: 	"{" >
|	<RBRACE: 	"}" >
|	<LBRACKET:	"[" >
|	<RBRACKET:	"]" >
|	<EOS:		";" >
|	<PARA:		"#" >
|	<AT:		"@" >
|	<BQ:		"`" >
|	<DOLLAR:	"$" >
|	<COMMA:		"," >
|	<COLON:		":" >
|	<ASSIGN:	"<=" >
|	<EQUAL:		"=" >
|	<IDENT: 	([ "a"-"z", "A"-"Z", "0"-"9", "_", ".", "'", "?", "\"" ])+>
|	<SPC_CHAR:	~[ " ", "\t"] >
|	<OTHER:		"[.]" >
}

void modules() :
{
}
{
	(
		<LIBRARY> skipTo( EOS )
	|	<USE> skipTo( EOS )
	|	entity()
	|	architecture()
	|	packageDef()
	)+
}

void entity() :
{	
	Token name ;
	Token end ;
}
{
	<ENTITY> name = identifier() <IS>
	{
		addModule( name.beginLine, name.image );
	}
	(
		genericList()
	|	portList()
	)*
	<END> [ <ENTITY> ] [ identifier() ] end = <EOS>
	{
		endModule( end.beginLine );
	}
}

void architecture() :
{
	Token end;
}
{
	<ARCHITECTURE> identifier() <OF> identifier() <IS>
	moduleBody()
	[<ARCHITECTURE>] [ identifier() ]
	end = <EOS>
	{
		endModule( end.beginLine );
	}
}


void packageDef() :
{
	Token name ;
	Token end ;
}
{
	<PACKAGE> [<BODY>] identifier() <IS>
	(
		packageDeclaration()
|		<COMPONENT> name = identifier() [<IS>]
		{
			addModule( name.beginLine, name.image );
		}
		(
			genericList()
		|	portList()
		)*
		end = <END> <COMPONENT> [identifier()] <EOS>
		{
			endModule( end.beginLine );
		}
	
	)+
	<END> [ <PACKAGE> ] [<BODY>] [identifier()] <EOS>
}

void genericList() :
{
}
{
	<GENERIC> "(" genericElement() ( ";" genericElement() )* ")" <EOS>
}

void genericElement() :
{
	Token port;
	Token postfix;
}
{
	{
		setPrefix("port ");
	}
	[ <CONSTANT> | <SIGNAL> | <VARIABLE> ]
	port = identifier()
	{
		addParameter(port.beginLine, port.image);
	}
	(
		","
		port = identifier()
		{
			addParameter(port.beginLine, port.image);
		}
	)*
	":"
	postfix = interfaceElementIndication()
	{
		setPostfix(postfix.image);
	}
}

void portList() :
{
}
{
	<PORT> "(" portElement() ( ";" portElement() )* ")" <EOS>
}

void portElement() :
{
	Token port;
	Token postfix;
}
{
	{
		setPrefix("port ");
	}
	[ <CONSTANT> | <SIGNAL> | <VARIABLE> ]
	port = identifier()
	{
		addPort(port.beginLine, port.image);
	}
	(
		","
		port = identifier()
		{
			addPort(port.beginLine, port.image);
		}
	)*
	":"
	postfix = interfaceElementIndication()
	{
		setPostfix(" : " + postfix.image);
	}
}

void moduleBody() :
{
	Token	module, inst, iend ;
}
{
	( declaration() )*
	<BEGIN>
	( statement() )*
	<END>
}

Token identifier() :
{
	Token token ;
}
{
	token = <IDENT>
	{
		return token ;
	}
}

void packageDeclaration() :
{
	Token variable;
	Token postfix;
}
{
	(
		( <CONSTANT> | <SIGNAL> | [ <SHARED> ] <VARIABLE> )
		{
			setPrefix(token.image + " ");
		}
		variable = identifier()
		{
			addVariable(variable.beginLine, variable.image);
		}
		(
			","
			variable = identifier()
			{
				addVariable(variable.beginLine, variable.image);
			}
		)*
		":"
		postfix = interfaceElementIndication()
		{
			setPostfix(" : " + postfix.image);
		}
		<EOS>
	)
|	( <TYPE> | <SUBTYPE> ) identifier() <IS> 
		(
			( <RECORD> skipEnd() <END> <RECORD> <EOS> )
		|	skipTo( EOS )
		)
|	( <FILE> | <ALIAS> | <ATTRIBUTE> | <FOR> | <DISCONNECT> | <GROUP> ) skipTo( EOS )
|	<PROCEDURE> 
		(
			<EOS>
		|	skipTo( BEGIN ) skipEnd() <END> [ <PROCEDURE> ][ identifier() ] <EOS>
		)
|	<FUNCTION> skipTo( RETURN ) identifier()
		(
			<EOS>
		|	skipTo( BEGIN ) skipEnd() <END> [ <FUNCTION> ] [ identifier() ] <EOS>
		)
}

void declaration() :
{
}
{
	packageDeclaration()
|	<COMPONENT> skipTo2( END, COMPONENT ) skipTo( EOS )
}

void statement() :
{
	Token ident, module, iend;
}
{
	(
		ident = identifier()
		(
			":" {beginStatement();}
			(				
			[<ENTITY>] module = identifier() iend = skipTo( EOS )
				{
					addInstance( ident.beginLine, iend.endLine, module.image, ident.image );
				}
			| <COMPONENT>  module = identifier() iend = skipTo( EOS )
				{
					addInstance( ident.beginLine, iend.endLine, module.image, ident.image );
				}
			|	( <IF> | <FOR> ) skipTo( GENERATE )
				(
					<BEGIN> ( statement() )* 
				|	( statement() )+
				)
				<END> <GENERATE> [identifier()] <EOS>
			|	<PROCESS> process()
			)
			{endStatement();}
		|	{beginStatement();} [ "(" skipParen() ")" ] skipTo( EOS )
			{endStatement();}
		)
	|	<WITH> {beginStatement();} skipTo( EOS ) {endStatement();}
	|	<PROCESS> {beginStatement();} process() {endStatement();}
	|	<BLOCK> {beginStatement();}
			skipTo2( END, BLOCK ) [ identifier() ] <EOS> {endStatement();}
	|	<ASSERT> {beginStatement();} skipTo( EOS ) {endStatement();}
	)
}

void process() :
{
}
{
	skipTo2( END, PROCESS ) [ identifier() ] <EOS>
}

JAVACODE
void unexpectedEof(Token token)
{
	ParseException ex = new ParseException("unexpected EOF");
	ex.currentToken = token;
	throw ex;
}

JAVACODE
Token skipTo( int skip )
{
	Token current = token;
	Token token;
	StringBuffer image = new StringBuffer();

	for(;;)
	{
		token = getToken(1);
		if ( token.kind == EOF )
			unexpectedEof(current);
		if (token.kind == skip)
		{
			getNextToken();
			break;
		}

		image.append(token.image);
		getNextToken();
	}
	token.image = image.toString();
	return token;
}

JAVACODE
void skipTo2(int skip1, int skip2)
{
	Token current = token;
	Token token;

	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == skip1)
		{
			getNextToken();
			token = getToken(1);
			if (token.kind == skip2)
			{
				getNextToken();
				break ;
			}
		}
		else
			getNextToken();
	}
}

JAVACODE
void skipParen()
{
	Token current = token;
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == LPAREN)
			nesting++;
		if (token.kind == RPAREN)
		{
			nesting--;
			if (nesting == 0)
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipEnd()
{
	Token current = token;
	Token token;
	int nesting = 1;
	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == BEGIN || token.kind == IF || token.kind == CASE || token.kind == LOOP)
			nesting++;
		if (token.kind == END)
		{
			nesting--;
			if (nesting == 0)
				break;
			else
				getNextToken();	// if or case
		}
		getNextToken();
	}
}

JAVACODE
Token interfaceElementIndication()
{
	Token current = token;
	Token token ;
	StringBuffer image = new StringBuffer();
	int nesting = 1;

	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == LPAREN)
			nesting++;
		if (token.kind == RPAREN)
		{
			nesting--;
			if (nesting == 0)
				break;
		}
		if (token.kind == EOS)
		{
			break ;
		}

		image.append(token.image + " ");
		getNextToken();
	}
	token.image = image.toString();
	return token ;
}


