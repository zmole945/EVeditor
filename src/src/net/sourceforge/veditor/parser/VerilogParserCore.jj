//
//  Copyright 2004, KOBAYASHI Tadashi
//  $Id$
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

options {
	JAVA_UNICODE_ESCAPE = true ;
	STATIC = false ;
}

PARSER_BEGIN(VerilogParserCore)

package net.sourceforge.veditor.parser;

public abstract class VerilogParserCore
{
	protected abstract void addModule(int begin, String name);
	protected abstract void endModule(int line);
	protected abstract void addPort(int line, String portName);
	protected abstract void addVariable(int line, String varName);
	protected abstract void addElement(int begin, int end, String type, String name);
	protected abstract void addInstance(int begin, int end, String module, String inst);
	protected abstract void beginStatement();
	protected abstract void endStatement();

	protected void parse() throws ParseException
	{
		modules();
	}
}

PARSER_END(VerilogParserCore)

//
// operation for /* */
//
MORE :
{
	"/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
	< ~[] >
}


//
// ignore from `else to `endif
//
<IN_ELSE_BLOCK>
SKIP :
{
	<ENDIF: "`endif" > : DEFAULT
}

<IN_ELSE_BLOCK>
MORE :
{
	< ~[] >
}

SKIP :
{
	" " | "\t" | "\r" | "\n" | "\f"
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "//" (~["\n"])* >
|	<DELSE:     "\n`else" > : IN_ELSE_BLOCK
|	<DIRECTIVE: "\n`" ["a"-"z"] (~["\n"])* >  // directive must be lower case
}

TOKEN :
{
	<MODULE:	"module">
|	<ENDMODULE: "endmodule">
|	<BEGIN: 	"begin">
|	<END:		"end">
|	<FORK:		"fork">
|	<JOIN:		"join">
|	<SPECIFY:	"specify">
|	<ENDSPECIFY:"endspecify">
|	<IF:		"if">
|	<ELSE:		"else">
|	<WHILE:		"while">
|	<FOR:		"for">
|	<CASE:		"case">
|	<CASEX:		"casex">
|	<ENDCASE:	"endcase">
|	<FUNCTION:	"function">
|	<ENDFUNCTION: "endfunction">
|	<TASK:		"task">
|	<ENDTASK:	"endtask">
|	<PORT_HEAD: 	( "input" | "output" | "inout") >
|	<VARIABLE_HEAD: ( "integer" | "real" | "wire" | "reg" | "event" ) >
|	<STMT_HEAD: (
		"parameter" | "time" |
		"assign" | "defparam" | "tri0" | "tri1" | "pullup" | "pulldown" |
		"buf"
	)>
|	<BLOCK_HEAD: ( "always" | "initial" )>
|	<LPAREN:	"(" >
|	<RPAREN:	")" >
|	<LBRACE: 	"{" >
|	<RBRACE: 	"}" >
|	<LBRACKET:	"[" >
|	<RBRACKET:	"]" >
|	<EOS:		";" >
|	<PARA:		"#" >
|	<AT:		"@" >
|	<BQ:		"`" >
|	<DOLLAR:	"$" >
|	<COMMA:		"," >
|	<COLON:		":" >
|	<EQUAL:		"=" >
|	<IDENT: 	([ "a"-"z", "A"-"Z", "0"-"9", "_", ".", "'", "?", "\"" ])+>
|	<SPC_CHAR:	~[ " ", "\t"] >
|	<OTHER:		"[.]" >
}

void modules() :
{
	Token name ;
	Token end ;
}
{
	(
		<MODULE> name = identifier()
		{
			addModule( name.beginLine, name.image );
		}
		[
			"(" [ argument() ( "," argument() )* ] ")"
		]
		<EOS>
		( moduleBody() )*
		end = <ENDMODULE>
		{
			endModule( end.beginLine );
		}
	)*
}

void argument() :
{
	Token ident;
}
{
		<PORT_HEAD> [ "[" skipTo(RBRACKET) ] ident = identifier()
		{
			addPort( ident.beginLine, ident.image );
		}
	|	identifier()
}

void moduleBody() :
{
	Token	module, inst, iend ;
}
{
//		LOOKAHEAD( 5 )
		<PORT_HEAD> {beginStatement();} port() {endStatement();}
	|	<VARIABLE_HEAD> {beginStatement();} variable() {endStatement();}
	|	<STMT_HEAD> {beginStatement();} skipTo( EOS ) {endStatement();}
	|	<BLOCK_HEAD> {beginStatement();} statement() {endStatement();}
	|	<SPECIFY> {beginStatement();} skipTo( ENDSPECIFY ) {endStatement();}
	|	<FUNCTION> {beginStatement();} function() {endStatement();}
	|	<TASK> {beginStatement();} task() {endStatement();}
	|	module = identifier() 
		{ beginStatement(); }
		[ "#" ( identifier() | <LPAREN> skipParen() <RPAREN> ) ]
		inst = identifier() "(" skipParen() ")" iend = ";"
		{
			addInstance( module.beginLine, iend.endLine, module.image, inst.image );
			endStatement();
		}
}

Token identifier() :
{
	Token token ;
}
{
	[ "`" ] token = <IDENT>
	{
		return token ;
	}
}

void port() :
{
	Token port ;
}
{
	[ "[" skipTo(RBRACKET) ]
	port = identifier()
	{
		addPort( port.beginLine, port.image );
	}
	(
		","
		port = identifier()
		{
			addPort( port.beginLine, port.image );
		}
	)*
	";"
}

void variable() :
{
	Token variable ;
}
{
	[ "[" skipTo(RBRACKET) ]
	variable = identifier() [ "[" skipTo(RBRACKET) ]
	{
		addVariable( variable.beginLine, variable.image );
	}
	(
		","
		variable = identifier() [ "[" skipTo(RBRACKET) ]
		{
			addVariable( variable.beginLine, variable.image );
		}
	)*
	(
		";"
	|	"=" skipTo( EOS )
	)
}

void delay() :
{
}
{
	( "@" | "#" ) ( "(" skipParen() ")" | identifier() )
}

void statement() :
{
}
{
	( delay() )*
	(	";"
	|	":" identifier()
	|	<STMT_HEAD> skipTo( EOS )
	|	ifStatement()
	|	block()
	|	"$" skipTo( EOS )
	|	"{" skipTo( EOS )
	|	identifier() skipTo( EOS )
	|	caseStatement()
	|	whileStatement()
	|	forStatement()
	)
}

void block() :
{
}
{
	( <BEGIN> | <FORK> )
	( statement() )*
	( <END> | <JOIN> )
}
void function() :
{
	Token name, end ;
}
{
	[ "[" skipBracket() "]" ]
	name = identifier()
	end = skipTo( ENDFUNCTION )
	{
		addElement( name.beginLine, end.endLine, "function", name.image );
	}
}

void task() :
{
	Token name, end ;
}
{
	[ "[" skipBracket() "]" ]
	name = identifier()
	end = skipTo( ENDTASK )
	{
		addElement( name.beginLine, end.endLine, "task", name.image );
	}
}

void ifStatement() :
{
}
{
	<IF> "(" skipParen() ")" statement()
	[ LOOKAHEAD(1) <ELSE> statement() ]
}

void caseStatement() :
{
}
{
	(<CASE>|<CASEX>) "(" skipParen() ")"
	(
		identifier() ( "," identifier() )* ":" statement()
	)*
	<ENDCASE>
}

void whileStatement() :
{
}
{
	<WHILE> "(" skipParen() ")" statement()
}

void forStatement() :
{
}
{
	<FOR> "(" skipParen() ")" statement()
}

JAVACODE
Token skipTo( int skip )
{
	Token token ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == skip )
		{
			getNextToken();
			break ;
		}
		getNextToken();
	}
	return token ;
}

JAVACODE
void skipParen()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == LPAREN )
			nesting++;
		if ( token.kind == RPAREN )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipBracket()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == LBRACKET )
			nesting++;
		if ( token.kind == RBRACKET )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}


JAVACODE
void skipToEndcase()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			throw new ParseException("unexpected EOF");
		if ( token.kind == CASE )
			nesting++;
		if ( token.kind == ENDCASE )
		{
			nesting--;
			if ( nesting == 0 )
			{
				getNextToken();
				break;
			}
		}
		getNextToken();
	}
}

