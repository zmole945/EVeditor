/*******************************************************************************
 * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    KOBAYASHI Tadashi - initial API and implementation
 *******************************************************************************/

options {
	JAVA_UNICODE_ESCAPE = true ;
	STATIC = false ;
}

PARSER_BEGIN(VerilogParserCore)

package net.sourceforge.veditor.parser;

public abstract class VerilogParserCore
{
	protected abstract void addModule(int begin, String name);
	protected abstract void endModule(int line);
	protected abstract void addPort(int line, String portName);
	protected abstract void addVariable(int line, String varName);
	protected abstract void addParameter(int line, String name, String value);
	protected abstract void addElement(int begin, int end, String type, String name);
	protected abstract void addInstance(int begin, int end, String module, String inst);
	protected abstract void beginStatement();
	protected abstract void endStatement();
	protected abstract void setPrefix(String fix);
	protected abstract void addPrefix(String fix);

	public void parse() throws ParseException
	{
		modules();
	}
}

PARSER_END(VerilogParserCore)

//
// operation for /* */
//
MORE :
{
	"/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
	< ~[] >
}


//
// ignore from `else to `endif
//
<IN_ELSE_BLOCK>
SKIP :
{
	<ENDIF: "`endif" > : DEFAULT
}

<IN_ELSE_BLOCK>
MORE :
{
	< ~[] >
}

SKIP :
{
	" " | "\t" | "\r" | "\n" | "\f"
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "//" (~["\n"])* >
|	<DELSE:     "\n`else" > : IN_ELSE_BLOCK
|	<DIRECTIVE: "\n`" ["a"-"z"] (~["\n"])* >  // directive must be lower case
}

TOKEN :
{
	<MODULE:	"module">
|	<ENDMODULE: "endmodule">
|	<BEGIN: 	"begin">
|	<END:		"end">
|	<FORK:		"fork">
|	<JOIN:		"join">
|	<SPECIFY:	"specify">
|	<ENDSPECIFY:"endspecify">
|	<IF:		"if">
|	<ELSE:		"else">
|	<WHILE:		"while">
|	<FOR:		"for">
|	<FOREVER:	"forever">
|	<REPEAT:	"repeat">
|	<CASE:		"case">
|	<CASEX:		"casex">
|	<ENDCASE:	"endcase">
|	<FUNCTION:	"function">
|	<ENDFUNCTION: "endfunction">
|	<TASK:		"task">
|	<ENDTASK:	"endtask">
|	<GENERATE:	"generate">
|	<ENDGENERATE:	"endgenerate">
|	<INPUT:		"input">
|	<OUTPUT:	"output">
|	<INOUT: 	"inout">
|	<INTEGER:	"integer">
|	<WIRE:		"wire">
|	<REG:		"reg">
|	<EVENT:		"event">
|	<GENVAR:	"genvar">
|	<REAL:		"real">
|	<PARAMETER:	"parameter"> 
|	<SIGNED:	"signed">
|	<STMT_HEAD: (
		"localparam" | "time" |
		"assign" | "defparam" | "tri0" | "tri1" | "pullup" | "pulldown" |
		"buf"
	)>
|	<BLOCK_HEAD: ( "always" | "initial" )>
|	<LPAREN:	"(" >
|	<RPAREN:	")" >
|	<LBRACE: 	"{" >
|	<RBRACE: 	"}" >
|	<LBRACKET:	"[" >
|	<RBRACKET:	"]" >
|	<EOS:		";" >
|	<PARA:		"#" >
|	<AT:		"@" >
|	<BQ:		"`" >
|	<DOLLAR:	"$" >
|	<COMMA:		"," >
|	<COLON:		":" >
|	<EQUAL:		"=" >
|	<IDENT: 	([ "a"-"z", "A"-"Z", "0"-"9", "_", ".", "'", "?", "\"" ])+>
|	<SPC_CHAR:	~[ " ", "\t"] >
|	<OTHER:		"[.]" >
}

void modules() :
{
	Token name ;
	Token end ;
}
{
	(
		<MODULE> name = identifier()
		{
			addModule( name.beginLine, name.image );
		}
		[
			"(" [ argument() ( "," argument() )* ] ")"
		]
		<EOS>
		( moduleBody() )*
		end = <ENDMODULE>
		{
			endModule( end.beginLine );
		}
	)*
}

void argument() :
{
	Token ident;
}
{
		portHead()
		ident = identifier()
		{
			addPort( ident.beginLine, ident.image );
		}
	|	identifier()
}

void portHead() :
{
	String mod, var;
}
{
	(
		"input"
	|	"output"
	|	"inout"
	)
	{
		setPrefix(token.image);
	}
	[ var = variableModifier() { addPrefix(" " + var);} ]
	bitRange()
}

void moduleBody() :
{
	Token	module, inst, iend ;
}
{
//		LOOKAHEAD( 5 )
		portHead() {beginStatement();} port() {endStatement();}
	|	<PARAMETER> {beginStatement();} parameter() {endStatement();}
	|	variableHead() {beginStatement();} variable() {endStatement();}
	|	<STMT_HEAD> {beginStatement();} skipTo( EOS ) {endStatement();}
	|	<BLOCK_HEAD> {beginStatement();} statement() {endStatement();}
	|	<SPECIFY> {beginStatement();} skipTo( ENDSPECIFY ) {endStatement();}
	|	<FUNCTION> {beginStatement();} function() {endStatement();}
	|	<TASK> {beginStatement();} task() {endStatement();}
	|	generate()
	|	module = identifier() 
		{ beginStatement(); }
		[ "#" ( identifier() | "(" skipParen() ")" ) ]
		inst = identifier() "(" skipParen() ")" iend = ";"
		{
			addInstance( module.beginLine, iend.endLine, module.image, inst.image );
			endStatement();
		}
}

void variableHead() :
{
	String mod;
}
{
	mod = variableModifier()
	{
		setPrefix(mod);
	}
	bitRange()
}

String variableModifier() :
{
	String value = null;
}
{
	(
			"real"
		|	"integer"
		|	"event"
		|	"genvar"
		|	"signed"
		|	"wire"	["signed" { value = "wire signed"; } ]
		|	"reg"	["signed" { value = "reg signed"; } ]
	)
	{
		if (value == null)
			return token.image;
		else
			return value;
	}
}

void bitRange() :
{
	Token msb, lsb;
}
{
	[
		"[" msb = skipTo(COLON) lsb = skipTo(RBRACKET)
		{
			addPrefix("[" + msb.image + ":" + lsb.image + "]");
		}
	]
	{
		addPrefix(" ");
	}
}

Token identifier() :
{
	Token token ;
}
{
	[ "`" ] token = <IDENT>
	{
		return token ;
	}
}

void port() :
{
	Token port ;
}
{
	port = identifier()
	{
		addPort( port.beginLine, port.image );
	}
	(
		","
		port = identifier()
		{
			addPort( port.beginLine, port.image );
		}
	)*
	";"
}

void variable() :
{
	Token variable ;
}
{
	variable = identifier() ( "[" skipTo(RBRACKET) )*
	{
		addVariable( variable.beginLine, variable.image );
	}
	(
		","
		variable = identifier() ( "[" skipTo(RBRACKET) )*
		{
			addVariable( variable.beginLine, variable.image );
		}
	)*
	(
		";"
	|	"=" skipTo( EOS )
	)
}

void parameter() :
{
}
{
	[
		<REAL>
	|	"[" skipTo(RBRACKET)
	]
	parameterAssign() ( "," parameterAssign() )* ";"
}


void parameterAssign() :
{
	Token parameter;
	Token value;
}
{
	parameter = identifier()
	"="
	value = skipToOr(COMMA, EOS)
	{
		addParameter(parameter.beginLine, parameter.image, value.image);
	}
}

void delay() :
{
}
{
	( "@" | "#" ) ( "(" skipParen() ")" | identifier() )
}

void statement() :
{
}
{
	( delay() )*
	(	";"
	|	":" identifier()
	|	<STMT_HEAD> skipTo( EOS )
	|	ifStatement()
	|	block()
	|	"$" skipTo( EOS )
	|	"{" skipTo( EOS )
	|	identifier() skipTo( EOS )
	|	caseStatement()
	|	whileStatement()
	|	forStatement()
	|	foreverStatement()
	|	repeatStatement()
	)
}

void block() :
{
}
{
	( <BEGIN> | <FORK> )
	( statement() )*
	( <END> | <JOIN> )
}
void function() :
{
	Token name, end ;
}
{
	[ "[" skipParen() "]" ]
	name = identifier()
	end = skipTo( ENDFUNCTION )
	{
		addElement( name.beginLine, end.endLine, "function", name.image );
	}
}

void task() :
{
	Token name, end ;
}
{
	name = identifier()
	end = skipTo( ENDTASK )
	{
		addElement( name.beginLine, end.endLine, "task", name.image );
	}
}

void generate() :
{
}
{
	<GENERATE>
	( generateStatement() )*
	<ENDGENERATE>
}

void generateStatement() : 
{
}
{
	generateForStatement()
|	generateIfStatement()
|	moduleBody()
}

void ifStatement() :
{
}
{
	<IF> "(" skipParen() ")" statement()
	[ LOOKAHEAD(1) <ELSE> statement() ]
}

void caseStatement() :
{
}
{
	(<CASE>|<CASEX>) "(" skipParen() ")"
	(
		identifier() ( "," identifier() )* ":" statement()
	)*
	<ENDCASE>
}

void whileStatement() :
{
}
{
	<WHILE> "(" skipParen() ")" statement()
}

void forStatement() :
{
}
{
	<FOR> "(" skipParen() ")" statement()
}

void foreverStatement() :
{
}
{
	<FOREVER> statement()
}

void repeatStatement() :
{
}
{
	<REPEAT> "(" skipParen() ")" statement()
}

void generateForStatement() :
{
}
{
	<FOR> "(" skipParen() ")"
	<BEGIN>
	[ ":" identifier() ]
	( generateStatement() )+
	<END>
}

void generateIfStatement() :
{
}
{
	<IF> "(" skipParen() ")"
	<BEGIN> ( generateStatement() )+ <END>
	[ LOOKAHEAD(1) <ELSE> <BEGIN> ( generateStatement() )+ <END> ]
}

JAVACODE
void unexpectedEof(Token token)
{
	ParseException ex = new ParseException("unexpected EOF");
	ex.currentToken = token;
	throw ex;
}

JAVACODE
Token skipTo(int skip)
{
	Token current = token;
	Token token ;
	StringBuffer image = new StringBuffer();

	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == skip)
		{
			getNextToken();
			break ;
		}

		image.append(token.image);
		getNextToken();
	}
	token.image = image.toString();
	return token ;
}

JAVACODE
Token skipToOr(int skip1, int skip2)
{
	Token current = token;
	Token token ;
	StringBuffer image = new StringBuffer();

	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == skip1 || token.kind == skip2)
		{
			// preserve skip token
			break ;
		}

		image.append(token.image);
		getNextToken();
	}
	token.image = image.toString();
	return token ;
}

JAVACODE
void skipParen()
{
	Token current = token;
	Token token;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken(1);
		if (token.kind == EOF)
			unexpectedEof(current);
		if (token.kind == LPAREN || token.kind == LBRACKET)
			nesting++;
		if (token.kind == RPAREN || token.kind == RBRACKET)
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipToEndcase()
{
	Token current = token;
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			unexpectedEof(current);
		if ( token.kind == CASE )
			nesting++;
		if ( token.kind == ENDCASE )
		{
			nesting--;
			if ( nesting == 0 )
			{
				getNextToken();
				break;
			}
		}
		getNextToken();
	}
}

