//
//  Copyright 2004, KOBAYASHI Tadashi
//  $Id$
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

options {
	JAVA_UNICODE_ESCAPE = true ;
	STATIC = false ;
}

PARSER_BEGIN(VerilogParser)

package net.sourceforge.veditor.editor;
import	java.io.*;
import java.util.*;

public class VerilogParser
{
	private List mods = new ArrayList();

	private void addModule( int line, String name )
	{
		mods.add( new VerilogSegment( line, name ) );
	}
	private void endModule( int line )
	{
		VerilogSegment mod = getCurrentModule();
		mod.setEndLine(line);
	}
	private void addReference( int begin, int end, String module, String inst )
	{
		VerilogSegment mod = getCurrentModule();
		mod.addReference( begin, end, module, inst );
	}
	private void addComment( int begin, String comment )
	{
		VerilogSegment mod = getCurrentModule();
		mod.addComment( begin, comment );
	}
	private VerilogSegment getCurrentModule()
	{
		int n = mods.size() - 1 ;
		return (VerilogSegment)mods.get( n );
	}

	//	âêÕåãâ ÇìæÇÈ
	public VerilogSegment getModule( int n )
	{
		return (VerilogSegment)mods.get( n );
	}
	public int size()
	{
		return mods.size();
	}
	
	public void parse() throws ParseException
	{
		modules();
	}
}

PARSER_END(VerilogParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* ÉRÉÅÉìÉgÇÃèàóù  */

MORE :
{
	"/*" : IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: (~["\n"]) "//" (~["\n"])* ("\n")>
|	<DIRECTIVE: "`" (~["\n"])* ("\n")>
/*
|	<IFDEF: 	"`ifdef" (~["\n"])* ("\n")>
|	<IFELSE: 	"`else" (~["\n"])* ("\n")>
|	<ENDIF: 	"`endif" (~["\n"])* ("\n")>
|	<INCLUDE: 	"`include" (~["\n"])* ("\n")>
|	<DEFINE: 	"`define" (~["\n"])* ("\n")>
|	<TIMESCALE: "`timescale" (~["\n"])* ("\n")>
*/
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
	< ~[] >
}

TOKEN :
{
	<LINE_COMMENT: "//" (~["\n"])* ("\n")>
|	<MODULE:	"module">
|	<ENDMODULE: "endmodule">
|	<BEGIN: 	"begin">
|	<END:		"end">
|	<SPECIFY:	"specify">
|	<ENDSPECIFY:"endspecify">
|	<IF:		"if">
|	<ELSE:		"else">
|	<WHILE:		"while">
|	<FOR:		"for">
|	<CASE:		"case">
|	<ENDCASE:	"endcase">
|	<FUNCTION:	"function">
|	<ENDFUNCTION: "endfunction">
|	<TASK:		"task">
|	<ENDTASK:	"endtask">
|	<STMT_HEAD: (
		"parameter" | "input" | "output" | "inout" |
		"integer" | "real" | "wire" | "reg" | "assign" |
		"defparam"
	)>
|	<BLOCK_HEAD: ( "always" | "initial" )>
|	<LPAREN:	"(">
|	<RPAREN:	")">
|	<LBRACE: 	"{" >
|	<RBRACE: 	"}" >
|	<LBRACKET:	"[" >
|	<RBRACKET:	"]" >
|	<EOS:		";">
|	<PARA:		"#">
|	<AT:		"@">
|	<BQ:		"`">
|	<DOLLAR:	"$">
|	<IDENT: 	((["`"])*[ "a"-"z", "A"-"Z", "0"-"9", "_"])+>
|	<SPC_CHAR:	~[]>
|	<OTHER:		"[.]">
}

void modules() :
{
	Token name ;
	Token end ;
}
{
	(
		<LINE_COMMENT>
	|
		<MODULE> name = <IDENT> [ <LPAREN> skipParen() <RPAREN> ] <EOS>
		{
			addModule( name.beginLine, name.image );
		}
		( moduleBody() )*
		end = <ENDMODULE>
		{
			endModule( end.beginLine );
		}
	)*
}

void moduleBody() :
{
	Token	module, inst, iend ;
}
{
		LOOKAHEAD( 5 )
		lineComment()
	|	<STMT_HEAD> skipTo( EOS )
	|	<BLOCK_HEAD> statement()
	|	<SPECIFY> (statement())* <ENDSPECIFY>
	|	<FUNCTION> function()
	|	<TASK> task()
	|	module = <IDENT> [ "#" <LPAREN> skipParen() <RPAREN> ]
		inst = <IDENT> "(" skipParen() ")" iend = ";"
		{
			addReference( module.beginLine, iend.endLine, module.image, inst.image );
		}
}

void lineComment() :
{
	Token comment ;
}
{
	comment = <LINE_COMMENT>
	{
		addComment( comment.beginLine, comment.image );
	}
}

void delay() :
{
}
{
	( "@" | "#" ) ( "(" skipParen() ")" | <IDENT> )
}

void statement() :
{
}
{
	[ delay() ]
	(	";"
	|	<LINE_COMMENT>
	|	ifStatement()
	|	<BEGIN> (statement())* <END>
	|	"$" skipTo( EOS )
	|	"{" skipTo( EOS )
	|	<IDENT> skipTo( EOS )
	|	caseStatement()
	|	whileStatement()
	|	forStatement()
	)
}

void function() :
{
	Token name, end ;
}
{
	[ "[" skipBracket() "]" ]
	name = <IDENT>
	end = skipTo( ENDFUNCTION )
	{
		addReference( name.beginLine, end.endLine, "function", name.image );
	}
}

void task() :
{
	Token name, end ;
}
{
	[ "[" skipBracket() "]" ]
	name = <IDENT>
	end = skipTo( ENDTASK )
	{
		addReference( name.beginLine, end.endLine, "task", name.image );
	}
}

void ifStatement() :
{
}
{
	<IF> "(" skipParen() ")" statement()
	[ LOOKAHEAD(1) <ELSE> statement() ]
}

void caseStatement() :
{
}
{
	<CASE> skipToEndcase()
}

void whileStatement() :
{
}
{
	<WHILE> "(" skipParen() ")" statement()
}

void forStatement() :
{
}
{
	<FOR> "(" skipParen() ")" statement()
}

JAVACODE
Token skipTo( int skip )
{
	Token token ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			break ;
		if ( token.kind == skip )
		{
			getNextToken();
			break ;
		}
		getNextToken();
	}
	return token ;
}

JAVACODE
void skipParen()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			break ;
		if ( token.kind == LPAREN )
			nesting++;
		if ( token.kind == RPAREN )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}

JAVACODE
void skipBracket()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			break ;
		if ( token.kind == LBRACKET )
			nesting++;
		if ( token.kind == RBRACKET )
		{
			nesting--;
			if ( nesting == 0 )
				break;
		}
		getNextToken();
	}
}


JAVACODE
void skipToEndcase()
{
	Token token ;
	int nesting = 1 ;
	for(;;)
	{
		token = getToken( 1 );
		if ( token.kind == EOF )
			break ;
		if ( token.kind == CASE )
			nesting++;
		if ( token.kind == ENDCASE )
		{
			nesting--;
			if ( nesting == 0 )
			{
				getNextToken();
				break;
			}
		}
		getNextToken();
	}
}

